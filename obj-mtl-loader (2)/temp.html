<!DOCTYPE html>
<html lang="kr">
<head>
    <title>three.js webgl - geometry - terrain</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <style>
        body {
            background-color: #bfd1e5;
            color: #61443e;
        }
        a {
            color: #a06851;
        }
    </style>
</head>
<body>

<div id="container"></div>
<div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
    - webgl terrain demo<br />
    (left click: forward, right click: backward)
</div>

<script type="module">

    import * as THREE from '../n/three.js-master/build/three.module.js';

    import Stats from '../n/three.js-master/examples/jsm/libs/stats.module.js';

    import { FirstPersonControls } from '../n/three.js-master/examples/jsm/controls/FirstPersonControls.js';
    import { ImprovedNoise } from '../n/three.js-master/examples/jsm/math/ImprovedNoise.js';
    import { OBJLoader} from "../n/three.js-master/examples/jsm/loaders/OBJLoader.js";
    import {MTLLoader} from "../n/three.js-master/examples/jsm/loaders/MTLLoader.js";

    let container, stats;

    let camera, controls, scene, renderer;

    let mesh, texture;

    let object1;

    let mtlLoader, loader;

    const worldWidth = 256, worldDepth = 256,
        worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

    const clock = new THREE.Clock();


    init();
    addDirectionalLight();
    loadMTLLoader('TUNA',0,0,0,1,1,1,0,0,0)

    animate();

    function addDirectionalLight() {
        let light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(-100, 0, 100);
        let light2 = new THREE.DirectionalLight(0xffffff, 1);
        light2.position.set(100, 0, 100);
        let light3 = new THREE.DirectionalLight(0xffffff, 1);
        light3.position.set(100, 0, -100);
        scene.add(light1);
        scene.add(light2);
        scene.add(light3);
    }
    /**
     * Material 파일을 로드하는 함수
     *
     * @method loadMTLLoader
     */
    function loadMTLLoader(str, xp, yp, zp, xs, ys, zs, xr, yr, zr) {
        mtlLoader = new MTLLoader();

        // MTLLoader Material 파일을 사용할 전역 경로를 설정합니다.
        mtlLoader.setPath('./resources/Umbreon/');

        // 로드할 Material 파일 명을 입력합니다.
        mtlLoader.load(str+'.mtl', function (materials) {
            // 로드 완료되었을때 호출하는 함수
            materials.preload();

            loadOBJLoader(materials, str, xp, yp, zp, xs, ys, zs, xr, yr, zr);
        }, function (xhr) {
            // 로드되는 동안 호출되는 함수
            console.log('MTLLoader: ', xhr.loaded / xhr.total * 100, '% loaded');
        }, function (error) {
            // 로드가 실패했을때 호출하는 함수
            console.error('MTLLoader 로드 중 오류가 발생하였습니다.', error);
            alert('MTLLoader 로드 중 오류가 발생하였습니다.');
        });
        animate();
    }



    /**
     * .obj 파일의 모델을 로드하는 함수
     *
     * @method loadObjLoader
     * @param {Object} materials MTLLoader에서 로드한 Materials 값
     * @param str
     * @param xp
     * @param yp
     * @param zp
     * @param xs
     * @param ys
     * @param zs
     * @param xr
     * @param yr
     * @param zr
     */
    function loadOBJLoader(materials, str, xp, yp, zp, xs, ys, zs, xr, yr, zr) {
        loader = new OBJLoader();

        // MTLLoader에서 로드한 materials 파일을 설정합니다.
        loader.setMaterials(materials);

        // OBJLoader OBJ 파일을 사용할 전역 경로를 설정합니다.
        loader.setPath('./resources/Umbreon/');

        // 로드할 OBJ 파일 명을 입력합니다.
        loader.load(str + '.obj', function (object) {
            // 모델 로드가 완료되었을때 호출되는 함수
            object.position.x = xp;
            object.position.y = yp;
            object.position.z = zp;
            object.scale.x = xs;
            object.scale.y = ys;
            object.scale.z = zs;
            object.rotation.x = xr;
            object.rotation.y = yr;
            object.rotation.z = zr;
            scene.add(object);
        }, function (xhr) {
            // 모델이 로드되는 동안 호출되는 함수
            console.log('OBJLoader: ', xhr.loaded / xhr.total * 100, '% loaded');
        }, function (error) {
            // 모델 로드가 실패했을 때 호출하는 함수
            console.log('ㅠㅠ');
        });

    }
    // function loadMTLLoader(str,) {
    //     mtlLoader = new MTLLoader();
    //
    //     // MTLLoader Material 파일을 사용할 전역 경로를 설정합니다.
    //     mtlLoader.setPath('./resources/Umbreon/');
    //
    //
    //     // 로드할 Material 파일 명을 입력합니다.
    //     mtlLoader.load('./spongebob-obj/spongebob.mtl', function (materials) {
    //         // 로드 완료되었을때 호출하는 함수
    //         materials.preload();
    //
    //         loadOBJLoader(materials);
    //     }, function (xhr) {
    //         // 로드되는 동안 호출되는 함수
    //         console.log('MTLLoader: ', xhr.loaded / xhr.total * 100, '% loaded');
    //     }, function (error) {
    //         // 로드가 실패했을때 호출하는 함수
    //         console.error('MTLLoader 로드 중 오류가 발생하였습니다.', error);
    //         alert('MTLLoader 로드 중 오류가 발생하였습니다.');
    //     });
    // }
    //
    // /**
    //  * .obj 파일의 모델을 로드하는 함수
    //  *
    //  * @method loadObjLoader
    //  * @param {Object} materials MTLLoader에서 로드한 Materials 값
    //  */
    // function loadOBJLoader(materials) {
    //     objLoader = new OBJLoader();
    //
    //     // MTLLoader에서 로드한 materials 파일을 설정합니다.
    //     objLoader.setMaterials(materials);
    //
    //     // OBJLoader OBJ 파일을 사용할 전역 경로를 설정합니다.
    //     objLoader.setPath('./resources/Umbreon/');
    //
    //
    //     // 로드할 OBJ 파일 명을 입력합니다.
    //     objLoader.load('./spongebob-obj/spongebob.obj', function (object) {
    //         // 모델 로드가 완료되었을때 호출되는 함수
    //         object.position.x = 3;
    //         object.position.y = 0;
    //         object.position.z = 0;
    //         object.scale.x = 5;
    //         object.scale.y = 5;
    //         object.scale.z = 5;
    //         object1 = object;
    //         scene.add(object1);
    //     }, function (xhr) {
    //         // 모델이 로드되는 동안 호출되는 함수
    //         console.log('OBJLoader: ', xhr.loaded / xhr.total * 100, '% loaded');
    //     }, function (error) {
    //         // 모델 로드가 실패했을 때 호출하는 함수
    //         alert('모델을 로드 중 오류가 발생하였습니다.');
    //     });
    // }
    function init() {

        container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xbfd1e5 );



        camera.position.set(3,3,3);

        let axes = new THREE.AxesHelper(10);
        scene.add(axes);
        var geometry = new THREE.CylinderGeometry(5000,5000,20000,32,1,true)
        var materialOuter = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load("./resources/Umbreon/GlobeInner_DM.png")
        });
        var materialInner = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load("./resources/Umbreon/GlobeInner_DM.png"),
            side: THREE.BackSide
        });

        var meshOuter = new THREE.Mesh(geometry, materialOuter);
        var meshInner = new THREE.Mesh(geometry, materialInner);
        meshOuter.add(meshInner);
        scene.add(meshOuter);
        {
            const loader = new THREE.CubeTextureLoader();
            const texture = loader.load([
                './resources/Umbreon/GlobeInner_DM.png',
                './resources/Umbreon/GlobeInner_DM.png',

                './resources/Umbreon/sea.jpg',
                './resources/Umbreon/bottom.png',
                './resources/Umbreon/GlobeInner_DM.png',
                './resources/Umbreon/GlobeInner_DM.png'

            ]);
            scene.background = texture;
        }
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        controls = new FirstPersonControls( camera, renderer.domElement );
        controls.movementSpeed = 50;
        controls.lookSpeed = 0.1;

        stats = new Stats();
        container.appendChild( stats.dom );

        //

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

    }





    //

    function animate() {


        requestAnimationFrame( animate );

        render();
        stats.update();

    }

    function render() {
        // object1.position.x += 0.01
        controls.update( clock.getDelta() );
        renderer.render( scene, camera );

    }

</script>

</body>
</html>