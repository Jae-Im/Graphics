<!DOCTYPE html>
<html lang="kr">
<head>
    <title>three.js webgl - geometry - terrain</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <style>
        body {
            background-color: #bfd1e5;
            color: #61443e;
        }

        a {
            color: #a06851;
        }
    </style>
</head>
<body>

<div id="container"></div>
<div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
    - webgl terrain demo<br/>
    (left click: forward, right click: backward)
</div>

<script type="module">

    import * as THREE from '../three.js-master/build/three.module.js';

    import Stats from '../three.js-master/examples/jsm/libs/stats.module.js';

    import {FirstPersonControls} from '../three.js-master/examples/jsm/controls/FirstPersonControls.js';
    import {ImprovedNoise} from '../three.js-master/examples/jsm/math/ImprovedNoise.js';
    import {OBJLoader} from "../three.js-master/examples/jsm/loaders/OBJLoader.js";
    import {MTLLoader} from "../three.js-master/examples/jsm/loaders/MTLLoader.js";

    let container, stats;

    let camera, controls, scene, renderer;
    var obj1 = [];
    let mesh, texture;
    let i = 0;
    let mtlLoader, loader;

    const worldWidth = 256, worldDepth = 256,
        worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

    const clock = new THREE.Clock();


    init();


    function init() {

        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xbfd1e5);


        camera.position.set(5, 5, 5);

        let axes = new THREE.AxesHelper(2500);
        scene.add(axes);
        var geometry = new THREE.CylinderGeometry(680, 680, 5000, 32, 1, true)
        var materialOuter = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load("./resources/sea_background.jpg")
        });
        var materialInner = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load("./resources/sea_background.jpg"),
            side: THREE.BackSide
        });

        var meshOuter = new THREE.Mesh(geometry, materialOuter);
        var meshInner = new THREE.Mesh(geometry, materialInner);
        meshOuter.add(meshInner);
        scene.add(meshOuter);
        {
            const loader = new THREE.CubeTextureLoader();
            const texture = loader.load([
                './resources/GlobeInner_DM.png',
                './resources/GlobeInner_DM.png',

                './resources/sea.jpg',
                './resources/bottom.png',
                './resources/GlobeInner_DM.png',
                './resources/GlobeInner_DM.png'

            ]);
            scene.background = texture;
        }
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        controls = new FirstPersonControls(camera, renderer.domElement);
        controls.movementSpeed = 50;
        controls.lookSpeed = 0.1;

        stats = new Stats();
        container.appendChild(stats.dom);

        //

        window.addEventListener('resize', onWindowResize, false);

        addDirectionalLight();
        loadMTLLoader('downtownbikinibottom', 1, -2500, 0, 1.5, 1.5, 1.5, 0, 0, 0);
        loadMTLLoader('./spongebob-obj/spongebob', -180, -2500, 0, 20, 20, 20, 0, 0.5, 0);
        for(var i=0; i<3; i++)
        {
            var rd = Math.random();
            loadMTLLoader('/spongebob-obj/spongebob', rd+i, rd-i, rd*i, 10, 10, 10, 0, 0, 0);
        }

		
			// input various type of objects 
	
	//
	for(var i=0; i<3; i++)
    {
      var rd = Math.random()*300+3500;
      loadMTLLoader('13002_American_Flagfish_v1_l3', rd+(4*i), rd-i, rd*i, 0.8, 0.8, 0.8, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    {
      var rd = Math.random()*500+2000;
      loadMTLLoader('12988_Electric_Yellow_cichlid_v1_l3', rd+(2*i), rd-i, rd*i, 0.8, 0.8, 0.8, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    {
      var rd = Math.random()*300+4500;
      loadMTLLoader('TUNA', rd+i, rd-i, rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	// sea turtle
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random()*300+600;
      loadMTLLoader('20446_Sea_Turtle_v1 Textured', rd+(2*i), rd-(2*i), rd*i, 0.4, 0.4, 0.4, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random();
      loadMTLLoader('10012_crab_v2_iterations-1', rd+(2*i), rd-(2*i), rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random();
      loadMTLLoader('bamboo shark', rd+(2*i), rd-(2*i), rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random();
      loadMTLLoader('CROCODIL', rd+(2*i), rd-(2*i), rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random();
      loadMTLLoader('DOLPHIN', rd+(2*i), rd-(2*i), rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random();
      loadMTLLoader('12265_Fish_v1_L2', rd+(2*i), rd-(2*i), rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random();
      loadMTLLoader('Patrick', rd+(2*i), rd-(2*i), rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random();
      loadMTLLoader('13103_pearlturtle_v1_l2', rd+(2*i), rd-(2*i), rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random();
      loadMTLLoader('12960_Shark_v2_L1', rd+(2*i), rd-(2*i), rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random();
      loadMTLLoader('TGRSHARK', rd+(2*i), rd-(2*i), rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	
	// sealion
	for(var i=0; i<3; i++)
    { 

      var rd = Math.random()*300+1000;
      loadMTLLoader('10041_sealion_v1_L3', rd+(2*i), rd-(2*i), rd*i, 0.3, 0.3, 0.3, -1.5708, -0.872665, 0);
    }
	
	// chromis
	for(var i=0; i<3; i++)
    {
      var rd = Math.random()*50+30;
      loadMTLLoader('13007_Blue-Green_Reef_Chromis_v2_l3', rd+(2*i), rd-i, rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	// gold fish
	for(var i=0; i<3; i++)
    {
      var rd = Math.random()*700+1000;
      loadMTLLoader('13001_Ryukin_Goldfish_v1_L3', rd+(2*i), rd-i, rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	// long fin fish
	for(var i=0; i<3; i++)
    {
      var rd = Math.random()*90+10;
      loadMTLLoader('12993_Long_Fin_White_Cloud_v1_l3', rd+(2*i), rd-i, rd*i, 1, 1, 1, -1.5708, 0, 0);
    }
	
	// whale
	for(var i=0; i<3; i++)
    {
      var rd = Math.random()*90+100;
      loadMTLLoader('10054_Whale_v2_L3', rd+(8*i), rd-i, rd*i, 0.2, 0.2, 0.2, -1.5708, 0, 0);
    }
		
        //loadMTLLoader('./spongebob-obj/spongebob', 1, 0, 0, 100, 100, 100, 0, 0, 0);
        //loadMTLLoader('downtownbikinibottom', 1, -50, 0, 1, 1, 1, 0, 0, 0);


        document.addEventListener('keyup', onKeyUp, false);

        function onKeyUp(event)
        {
            if (event.key === 'c') {
                let light4 = new THREE.DirectionalLight(0xffffff, 1);
                scene.add(light4);

            }
        }

        animate();


        function addDirectionalLight() {
            let light1 = new THREE.DirectionalLight(0xffffff, 1);
            light1.position.set(-100, 0, 100);
            let light2 = new THREE.DirectionalLight(0xffffff, 1);
            light2.position.set(100, 0, 100);
            let light3 = new THREE.DirectionalLight(0xffffff, 1);
            light3.position.set(100, 0, -100);

            scene.add(light1);
            scene.add(light2);
            scene.add(light3);

        }

        /**
         * Material 파일을 로드하는 함수
         *
         * @method loadMTLLoader
         */
        function loadMTLLoader(str, xp, yp, zp, xs, ys, zs, xr, yr, zr) {
            mtlLoader = new MTLLoader();

            // MTLLoader Material 파일을 사용할 전역 경로를 설정합니다.
            mtlLoader.setPath('./resources/');

            // 로드할 Material 파일 명을 입력합니다.
            mtlLoader.load(str + '.mtl', function (materials) {
                // 로드 완료되었을때 호출하는 함수
                materials.preload();

                loadOBJLoader(materials, str, xp, yp, zp, xs, ys, zs, xr, yr, zr);
            }, function (xhr) {
                // 로드되는 동안 호출되는 함수
                console.log('MTLLoader: ', xhr.loaded / xhr.total * 100, '% loaded');
            }, function (error) {
                // 로드가 실패했을때 호출하는 함수
                console.error('MTLLoader 로드 중 오류가 발생하였습니다.', error);
                alert('MTLLoader 로드 중 오류가 발생하였습니다.');
            });
        }


        /**
         * .obj 파일의 모델을 로드하는 함수
         *
         * @method loadObjLoader
         * @param {Object} materials MTLLoader에서 로드한 Materials 값
         * @param str
         * @param xp
         * @param yp
         * @param zp
         * @param xs
         * @param ys
         * @param zs
         * @param xr
         * @param yr
         * @param zr
         */
        function loadOBJLoader(materials, str, xp, yp, zp, xs, ys, zs, xr, yr, zr) {
            loader = new OBJLoader();

            // MTLLoader에서 로드한 materials 파일을 설정합니다.
            loader.setMaterials(materials);

            // OBJLoader OBJ 파일을 사용할 전역 경로를 설정합니다.
            loader.setPath('./resources/');

            // 로드할 OBJ 파일 명을 입력합니다.
            loader.load(str + '.obj', function (object) {
                // 모델 로드가 완료되었을때 호출되는 함수
                object.position.x = xp;
                object.position.y = yp;
                object.position.z = zp;
                object.scale.x = xs;
                object.scale.y = ys;
                object.scale.z = zs;
                object.rotation.x = xr;
                object.rotation.y = yr;
                object.rotation.z = zr;
                obj1.push(object);
                scene.add(object);
                let animation = function(){
                    if(i !== 0) {
                        obj1[i].position.x += 0.01;
                        requestAnimationFrame(animation);
                        render();
                    }
                }
                i++;
                // animation();
            }, function (xhr) {
                // 모델이 로드되는 동안 호출되는 함수
                console.log('OBJLoader: ', xhr.loaded / xhr.total * 100, '% loaded');
            }, function (error) {
                // 모델 로드가 실패했을 때 호출하는 함수
                console.log('OBJ load failed');
            });


        }
        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            controls.handleResize();

        }


        //

        function animate() {
            requestAnimationFrame(animate);

            render();
            stats.update();

        }

        function render() {
            controls.update(clock.getDelta());
            renderer.render(scene, camera);

        }
    }



</script>

</body>
</html>
